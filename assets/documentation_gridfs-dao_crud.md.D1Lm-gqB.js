import{_ as a,c as i,o as t,a2 as s}from"./chunks/framework.B4IoZSds.js";const u=JSON.parse('{"title":"CRUD Functions","description":"","frontmatter":{},"headers":[],"relativePath":"documentation/gridfs-dao/crud.md","filePath":"documentation/gridfs-dao/crud.md","lastUpdated":1758723910000}'),n={name:"documentation/gridfs-dao/crud.md"};function l(o,e,d,r,p,h){return t(),i("div",null,[...e[0]||(e[0]=[s(`<h1 id="crud-functions" tabindex="-1">CRUD Functions <a class="header-anchor" href="#crud-functions" aria-label="Permalink to &quot;CRUD Functions&quot;">​</a></h1><h2 id="create" tabindex="-1">Create <a class="header-anchor" href="#create" aria-label="Permalink to &quot;Create&quot;">​</a></h2><p>You need a filename, an input stream and some kind of metadata.</p><p>Possible Metadata types:</p><ul><li>Document</li><li>Map</li><li>Scala Case Class</li></ul><p>Return Observable of ObjectId.</p><div class="language-scala vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">scala</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ImageFilesDAO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.insertOne(filename, stream, metadata)</span></span></code></pre></div><h2 id="update" tabindex="-1">Update <a class="header-anchor" href="#update" aria-label="Permalink to &quot;Update&quot;">​</a></h2><div class="warning custom-block"><p class="custom-block-title">Official_MongoDB_Documentation</p><p>Do not use GridFS if you need to update the content of the entire file atomically. As an alternative you can store multiple versions of each file and specify the current version of the file in the metadata. You can update the metadata field that indicates “latest” status in an atomic update after uploading the new version of the file, and later remove previous versions if needed.Do not use GridFS if you need to update the content of the entire file atomically. As an alternative you can store multiple versions of each file and specify the current version of the file in the metadata. You can update the metadata field that indicates “latest” status in an atomic update after uploading the new version of the file, and later remove previous versions if needed.</p></div><h2 id="delete" tabindex="-1">Delete <a class="header-anchor" href="#delete" aria-label="Permalink to &quot;Delete&quot;">​</a></h2><p>GridFSFile will be deleted by a given ObjectID.</p><p>With implicit conversion you can use for OID Parameter:</p><ul><li>ObjectID</li><li>GridFSFile</li><li>String</li></ul><div class="language-scala vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">scala</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mongocamp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">driver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mongodb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ImageFilesDAO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.deleteOne(oid)</span></span></code></pre></div>`,14)])])}const k=a(n,[["render",l]]);export{u as __pageData,k as default};
